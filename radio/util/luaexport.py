#!/usr/bin/env python
# -*- coding: utf-8 -*-


import sys
import traceback
import time

PREC1 = 10
PREC2 = 100

CONSTANT_VALUE = ""
dups_cnst = []
dups_name = []
exports = []
exports_multiple = []
exports_script_outputs = None

warning = None
error = None

def checkName(name):
	global warning
	if name in dups_name:
		print "WARNING: Duplicate name %s found for constant %s" % (name, CONSTANT_VALUE)
		warning = True
	dups_name.append(name)
	if name != name.lower():
		print "WARNING:Name not in lower case %s found for constant %s" % (name, CONSTANT_VALUE)
		warning = True


def LEXP(name, description, scale = 1, transform = None):
	#print "LEXP %s, %s, %s, %s" % (name, description, scale, transform)
	checkName(name)
	exports.append( (CONSTANT_VALUE, name, description, scale, transform) )

def LEXP_MULTIPLE(nameFormat, descriptionFormat, firstValue, numOfValues):
	print "LEXP_MULTIPLE %s, %s, %s, %s" % (nameFormat, descriptionFormat, firstValue, numOfValues)
	first = int(firstValue)
	last = first + int(numOfValues) - 1
	for v in range(first, last+1):
		name = nameFormat % v
		#print name
		checkName(name)
	exports_multiple.append( (CONSTANT_VALUE, nameFormat, descriptionFormat, first, last) )

def LEXP_SCRIPT_OUTPUTS(noScripts, noOutputsPerScript):
	print "LEXP_SCRIPT_OUTPUTS %s, %s" % (noScripts, noOutputsPerScript)


inputFile = sys.argv[1]
outputFile = sys.argv[2]
print "Input file %s" % inputFile
print "Output file %s" % outputFile

inp = open(inputFile, "r")

while True:
	line = inp.readline()
	if len(line) == 0:
		break
	line = line.strip('\r\n')
	line = line.strip()
	#print "line: %s"  % line

	parts = line.split('LEXP')
	#print parts
	if len(parts) != 2:
		print "Wrong line: %s" % line
		continue
	cmd = 'LEXP' + parts[1]
	cnst = parts[0].rstrip(', ')
	if cnst.find('=') != -1:
		# constant contains =
		cnst = cnst.split('=')[0].strip()
	#print "Found constant %s with command: %s" % (cnst, cmd)
	try:
		CONSTANT_VALUE = cnst
		if CONSTANT_VALUE in dups_cnst:
			print "WARNING: Duplicate CONSTANT_VALUE found: %s" % CONSTANT_VALUE
			warning = True
			continue
		dups_cnst.append(CONSTANT_VALUE)
		eval(cmd)
	except:
		traceback.print_exc()
		error = True

inp.close()

out = open(outputFile, "w")

out.write("//This file was generated by luaexport.py script on %s\n" % time.asctime())
out.write("\n\n\n")
out.write("const int luaFielsNum = %d;	//the number of items in luaFields[]\n" % len(exports))
out.write("const LuaField luaFields[] = { //this aray is alphabetically sorted by the second field (name)\n")

exports.sort(key = lambda x: x[1])  #sort by name
firstLine = True
for (cnst, name, desc, scale, transf) in exports:
	if firstLine:
		firstLine = False
	else:	
		out.write(",\n")
	out.write("  {%s, \"%s\", \"%s\", %d, %s}" % (cnst, name, desc, scale, transf) )
out.write("\n};\n\n")


out.write("const int luaMultipleFielsNum = %d;	//the number of items in luaMultipleFields[]\n" % len(exports_multiple))
out.write("const LuaMultipleField luaMultipleFields[] = {\n")
firstLine = True
for (cnst, nameFormat, descriptionFormat, first, last) in exports_multiple:
	if firstLine:
		firstLine = False
	else:	
		out.write(",\n")
	out.write("  {%s, \"%s\", \"%s\", %d, %d}" % (cnst, nameFormat, descriptionFormat, first, last) )
out.write("\n};\n\n")




out.close()

if warning:
	sys.exit(1)
elif error:
	sys.exit(2)
sys.exit(0)